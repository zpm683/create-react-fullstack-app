import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="React/3 React生态圈/3.1 ECMAScript" />

### ECMAScript6+

    ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。
    它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。

    简单的说，ECMAScript6(ES6)其实就是JS的一个比较新的版本,我们以前熟知的JS其实算是ECMAScript5(ES5)。
    ES6比起ES5加了很多新功能，所以我们现在往往把新版本的JS称为ES6,ES7等。
    从ES6开始，JS的升级速度越来越快了，基本上每年都会有所变化。
    现在让我们来看看ES6的最核心最常用的语法吧。

2.1.1 常见语法

- let/const
  我们现在使用 let 和 const 来定义变量了，相比以前的 var，  
  它们最大的特色是都具有块级作用域，这大大提升了变量的可维护性，避免了 var 带来的困扰。

```javascript
/**
 * 基本用法
 */
var x = 1; // old
let y = 1; // 新方法定义一个 y变量（可多次赋值）
const z = 1; // 新方法定义一个 z变量（只能赋一次值）
y = 2; // 正确
z = 2; // 错误 z已经是1了，不能再次赋值！

/**
 * 定义对象时有所不同
 */
// 使用let定义对象/数组
let obj1 = {
  name: "z",
};
// 使用const定义对象/数组
const obj2 = {
  name: "z",
};
obj1 = {}; // 正确 可以给obj1重新任何赋值
obj2 = {}; // 错误 不可以再给obj2重新赋值
obj2.name = "y"; // 正确 可以再给obj2内部属性重新赋值

/**
 * 块级作用域！
 */
function Fn() {
  let age = 1;
  const obj = {
    data: "xxx",
  };
  const insideFn = function () {
    let _temp = "temp";
  };
  console.log(age); // 正确
  console.log(obj); // 正确
  console.log(_temp); // undefined
}
console.log(age); // undefined
console.log(obj); // undefined
console.log(_temp); // undefined
console.log(insideFn); // 正确
```

从上面的例子不难看出 let 和 const 的特点。
它们都具有块级作用域！都用来定义变量，但是 const 一旦被定义就引用（栈地址）就无法再更改了。  
 这也是为什么 const 对象获或者数组的内部还能更改（堆地址）。

- ...解构赋值

```javascript
/**
 * 基本用法
 */
let [a, b, c] = [1, 2, 3];
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3

let [head, ...tail] = [1, 2, 3, 4];
// head会自动对应数组的第一个元素
console.log(head); // 1
// tail是包含剩下的元素的数组
console.log(tail); // [2, 3, 4]

const obj = {
  id: 1,
  name: "Zhang",
  age: 23,
};
const { id, age, ...some } = obj;
// 解构出了对象中的id对应的值
console.log(id); //1
// some是包含剩下的属性的对象
console.log(some); //  { name: "Zhang" }

/**
 * 特殊例子
 * 这种做法后续会在React复制上一个state/props时非常有用！
 * 会在跳坑指南中详细描述！
 */
const obj = {
  data: "some data",
};
const objCopy = { ...obj };
// 上面的例子里obj和objCopy内的数据是一致的。
// 但是要注意的是二者的引用是不同的。
```

综上，当我们有一个复杂的数据结构需要被拆解时，解构赋值是非常方便的，可以让你写出优雅的代码！

- ()=>{} 箭头函数
  箭头函数是普通函数的一个语法糖，建议多使用它！

```javascript
/**
 * 基本用法
 */
// old！
function add(number) {
   return number + 1;
}
// new！
const add = (number) => {number + 1}
// 二者调用一致 ： console.log(add(0))  //1

/**
 * 箭头函数中没有this，也没有原型
 */
const fn = () => {
  console.log(this) // undefined
}

/**
 * 箭头函数不同于function，需要先定义后使用。
 */
doSome() // 错误！
const doSome = () => {}
doSome() // 正确！

/**
 * 花式定义
 */
const fn1 = () => {}; // 什么也不做
const fn2 = () => (); // 返回一个undefined
const fn3 = () => [1,2,3]; // 返回一个[1,2,3]
const fn4 = () => 1; // 返回1
const fn5 = () => undefined; // 返回undefined
const fn6 = (x,y) => x+y; // 返回 x+y的结果
const fn7 = (x,y) => {
  return x+y;  // 返回 x+y的结果, 等价于 fn6
}
```

- ` `和单/双引号一样，用来定义一个字符串，  
  但是它可以在内部通过\$符号加入变量！

```javascript
const str1 = "1";
const str2 = "s";
// old!
const sub1 = str1 + str2; // "1s"
// new!
const sub2 = `${str1}${str2}`; // "1s"
```

由于它底层使用了 concat，性能比+拼接字符串要好，请多多使用！

- class
  从 ES6 开始现在支持定义 class 了，如果你熟悉面向对象的高级语言，你会非常熟悉它  
  但是 class 最终还是会转换为 function！  
  少使用 class,多使用箭头函数(function),可以提高性能！

- Module 的语法

```javascript
/**
 * 导入
 */
// old!
let { stat, exists, readfile } = require("fs");
// new!
import { stat, exists, readFile } from "fs";

/**
 * 导出
 */
export const x = 1;
//导出多个方法
export const fn1 = () => {};
export const fn2 = () => {};

// 在其他文件导入它们, 并给fn2换名字为fn3
import { x, fn1, fn2 as fn3 } from "xx/xx"; //xxxx是定义它们的文件相对路径

//默认导出（不推荐使用）（一个文件只能有一个默认导出）
const data = "xxx";
export default data;
// 在其他文件导入 data
import data from "xx/xx"; // data === "xxx"
import data1 from "xx/xx"; // data1 === "xxx" 虽然换了名字但还是data
// 正是因为默认导出名字可以被随意替换，基于可维护性考虑，不推荐。
```

- async/await
  这是目前前端最易用的异步解决方案了。  
  前端异步发展从 callback-->promise-->yield-->async/await  
  经历了种种实践，最终来到了现在的 asnyc/await 时代！

```javascript
// callback
let data;
axios.get("/api", (err, res) => {
  if (!err) data = res.data;
});

// promise
const getData = (req) => {
  return new Promise((resolve, reject) => {
    axios.get("/api/", (err, res) => {
      err ? reject(err) : resolve(res.data);
    });
  });
};
getData(1)
  .then((data) => {
    // todo
  })
  .catch((err) => {
    // todo
  });

// yield
function* g3() {
  yield* [1, 2];
  yield* "34";
  yield* arguments;
}
const iterator = g3(5, 6);
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: "3", done: false }
console.log(iterator.next()); // { value: "4", done: false }
console.log(iterator.next()); // { value: 5, done: false }
console.log(iterator.next()); // { value: 6, done: false }
console.log(iterator.next()); // { value: undefined, done: true

// async/await
const asyncFn = async () => {
  try {
    // getData处于resolve状态时data1获得返回的值
    const data1 = await getData(1); //getData是promise，如果不是会被自动转换为promise
    // 成功获得data1时才会继续执行下面的语句
    const data2 = await getData(data1); //getData是promise
    return { data1, data2 };
  } catch (e) {
    // 上面任何一个await的方法被reject都会触发catch
    // todo
  }
};
```

callback 存在回调地狱问题,promise 有些复杂,yield 不好理解。  
 相比之下，async/await 的方式更加“同步”一些。并且非常方便连续调用多个异步方法！  
 有时我们会定义一些 promise 方法然后在 async/await 中连续调用。  
 好在现在的各种库的异步方法基本上都是 promise，所以一般都是直接使用 async/await。

2.1.2 进阶指南

- [ECMAScript 是啥](https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin)
- [《ECMAScript 6 入门》阮一峰](https://es6.ruanyifeng.com/)
- [解构赋值原理](https://blog.csdn.net/zyz00000000/article/details/107629419)
- [异步 Promise 及 Async/Await 可能最完整入门攻略](https://segmentfault.com/a/1190000016788484)
- [this 指向详细解析（箭头函数）](https://www.cnblogs.com/dongcanliang/p/7054176.html)

---
