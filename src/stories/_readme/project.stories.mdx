import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Readme/规约" />

#### 规约

不同的项目规约不尽相同，但是只要定下规约就一定要义无反顾的执行下去。  
正所谓“约定优于配置!”  
下面以 create-react-fullstack-app(TS)为例：

##### 命名规约

- 包命名全部小写，多个词以中划线连接（xxx，xx-xx，xx-xx-xxx）
- 下划线开头的包是临时的（ \_demo, \_xxxx ）
- 工程入口为 index.tsx
- React 组件后缀必须是 .tsx
- 非 React 组件后缀必不是 .tsx
- React 组件/ES6 类：大驼峰式命名 （Login.tsx, BrowserUtils.ts）
- 非类/组件：小驼峰式命名（rootReducer.ts, router.ts）
- 各业务根组件命名应该与包名一致（Login-->Login.tsx）
- interface & type 大驼峰式命名（RequestData，ResponseData）
- 一般变量小驼峰式命名（x，xxxXxxx）
- 常量全大写，下划线连接（SEVER_CONFIG, XXXX_XXXX）

##### 类型定义规约

- 公共类型或公共接口需要在&#64;types 文件夹内定义 (xxx.d.ts)
- xxx.d.ts 内需要定义为模块 （declare module [包名].[.d.ts 文件名].[类别]{}）
- API 对应接口文件 api.d.ts，一般指定了 RequestData 与 ResponseData 的类型
- 参数接口文件 params.d.ts，一般指定了多组片段类型每一块都用 declare module 包裹（也可以拆分为多个.d.ts 文件）

```
/**
 * params.d.ts
 */
declare module "login.params.base" {
  export type UserId = string;
  export type Password = string;
  export type LoginInfo = {
    userId: UserId;
    password: Password;
  };
}
declare module "login.params.xxx" {
  export type xxx = string;
}
```

```
/**
 * api.d.ts
 */
declare module "login.api.loginApi" {
  import { Password, UserId } from "login.params.base";
  /** RequestData type */
  export type RequestData = {
    user: UserId;
    pass: Password;
  };
  /** ResponseData type */
  export type ResponseData = {
    token: string;
  };
}
```

##### 组件规约

- 尽量定义为函数式组件

```
// 方式一
/**
* 登录组件
*/
type LoginProps = {};
export default function Login(props:LoginProps) {}

// 方式二（推荐: React.FC接口会自动添加child属性，便于拓展, 同时还能支持props析构展开）
/**
* 登录组件
*/
type LoginProps = {};
export const Login:React.FC<LoginProps> = (props) => {}
//props析构展开
export const Login:React.FC<LoginProps> = ({child，xxx，...props }) => {}
```

- 使用 useSelector Hook 时尽可能只取需要的值，必要时要使用 useMemo 优化渲染
- 复杂的组件内,按需使用懒加载来优化性能

```
const Xxxxxx = React.lazy(() => import('../../../Xxxxxx'));
```

##### 其他规约

- common 内的组件必须在 storybook 中展示以便其他人快速了解公共的组件
- 在当前包中导入其他功能包中的对象时，必须从它最外层的 index.ts(导出管理)中导入  
  其他包内并不是所有带有 export 的对象都希望在外部被调用（这也是 index.ts 导出管理文件存在的意义）

```
//当前在menu包中需要调用login包的Action
// 正确做法
import { loginActions } from "../../../login";
// 错误做法
import { loginActions } from "../../../login/src/redux/loginSlice";
```

- 由于使用了 material-ui，尽可能使用 JSS 定义 style 而不是外部文件
- index.ts(导出管理)中根组件应该默认导出
- 组件中有复杂的条件渲染时，应该抽出为一个渲染方法: function renderXxxxx(){}
- 导入包时，使用相对路径而不是绝对路径
- 每一个需要使用路由的组件，都应该在 common-->config-->AppPaths.ts 中列举
- 写好注解，尤其是接口
- 尽可能使用 ES6+的语法处理数据
- 由于使用了 RTK，Redux 包下只能出现 xxxxSlice.ts 文件
- 不要自定义全局变量，而是通过 Redux 进行管理
- 定义 Action（Redux）时，开头应该是一种动词（同步：setXxxxx，changeXxxxx，whenXxxxx，异步：doXxxxx）
- default 导出被认为是有害的 最好一般导出而不要使用 export default xxx
- 在定义一个组件的时候经可能把同类型的方法集中在一起, 并且按如下顺序摆放:  
  这样可以降低后期维护难度。大家以后写组件的时候尽可能按如下 demo 的顺序写。

```javascript
export const Demo = ({props}) => {
  ////////// hooks start  ///////////
  const  [state, setState] = useState();
  const dispatch = useDispatch();
  ....
  ////////// hooks end  ///////////

  //////////// useEffect functions start /////////
  useEffect (()=>{},[])
  useEffect (()=>{},[state])
  useEffect (()=>{},[props])
  ...
  ////////////useEffect functions end /////////

  ////////// logic functions start ////////////////
  const handlClick = () =>{
  }
  const  xxFn = () => {}
  ....
  ////////// logic functions end ////////////////

  ////////////////// render functions start////////////////
  const renderTitle = () => {....}
  const renderAppBar = () => {....}
  const renderTable = () => {....}
  ...
  return (
  <>
    <h1>{renderTitle()}</h1>
    <div>{renderAppBar()}</div>
     <div>{renderTable()}</div>
  </>
);
  ////////////////// render functions end ////////////////
}
```

---
